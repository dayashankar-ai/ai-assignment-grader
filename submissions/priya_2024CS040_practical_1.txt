STUDENT_NAME: Priya Sharma
STUDENT_ID: 2024CS040
STUDENT_EMAIL: priya.sharma@university.edu
BATCH: 2024
PRACTICAL_NUMBER: 1

=== TEMPERATURE TESTING PROGRAM ===

```python
# Temperature Sensor Testing Program
# Author: Priya Sharma
# Date: January 28, 2026

import random
import time

class TemperatureSensor:
    """Class to simulate temperature sensor readings"""
    
    def __init__(self, sensor_id):
        self.sensor_id = sensor_id
        self.readings = []
    
    def read(self):
        """Take a single temperature reading"""
        # Simulate sensor reading with small variation
        temperature = round(random.uniform(22.0, 28.0), 2)
        timestamp = time.strftime("%H:%M:%S")
        self.readings.append(temperature)
        return temperature, timestamp
    
    def get_statistics(self):
        """Calculate statistics from all readings"""
        if not self.readings:
            return None
        
        return {
            'count': len(self.readings),
            'average': round(sum(self.readings) / len(self.readings), 2),
            'maximum': max(self.readings),
            'minimum': min(self.readings),
            'range': round(max(self.readings) - min(self.readings), 2)
        }

def display_header():
    """Display program header"""
    print("=" * 50)
    print("TEMPERATURE SENSOR TESTING PROGRAM")
    print("=" * 50)
    print()

def display_reading(reading_num, temp, timestamp):
    """Display a single reading"""
    status = "NORMAL" if 20 <= temp <= 30 else "WARNING"
    print(f"[{timestamp}] Reading #{reading_num}: {temp}°C [{status}]")

def display_statistics(stats):
    """Display statistical summary"""
    print("\n" + "=" * 50)
    print("STATISTICAL SUMMARY")
    print("=" * 50)
    print(f"Total Readings: {stats['count']}")
    print(f"Average Temperature: {stats['average']}°C")
    print(f"Maximum Temperature: {stats['maximum']}°C")
    print(f"Minimum Temperature: {stats['minimum']}°C")
    print(f"Temperature Range: {stats['range']}°C")
    
    # Overall assessment
    avg = stats['average']
    if avg < 20:
        status = "TOO COLD"
    elif avg > 30:
        status = "TOO HOT"
    else:
        status = "OPTIMAL"
    
    print(f"\nOverall Status: {status}")
    print("=" * 50)

def main():
    """Main program execution"""
    display_header()
    
    # Initialize sensor
    sensor = TemperatureSensor("TEMP-001")
    
    print("Initializing sensor...")
    time.sleep(0.5)
    print("Taking 10 temperature readings...\n")
    
    # Take 10 readings
    for i in range(1, 11):
        temp, timestamp = sensor.read()
        display_reading(i, temp, timestamp)
        time.sleep(0.3)  # Small delay between readings
    
    # Display statistics
    stats = sensor.get_statistics()
    display_statistics(stats)

if __name__ == "__main__":
    main()
```

=== LEARNING SUMMARY ===

What I learned in this practical:

1. **Object-Oriented Programming**: Created a TemperatureSensor class to encapsulate sensor functionality. This demonstrates encapsulation and data abstraction.

2. **Data Structures**: Used lists to store temperature readings and dictionaries to organize statistical data.

3. **Functions and Modularity**: Broke down the program into multiple functions (display_header, display_reading, display_statistics) for better code organization and reusability.

4. **String Formatting**: Used f-strings for formatted output with proper alignment and decimal precision.

5. **Conditional Logic**: Implemented temperature status checking with if-elif-else conditions to classify readings.

6. **Python Standard Library**: 
   - random module for simulating sensor data
   - time module for timestamps and delays

Challenges Encountered:
- Initially struggled with organizing the code structure - solved by creating separate display functions
- Had to figure out how to store readings in the class - used a list attribute
- Understanding when to use class methods vs regular functions
- Formatting the output to look professional and readable

Technical Improvements Made:
- Added proper docstrings to all functions and classes
- Implemented error handling for empty readings list
- Used meaningful variable names throughout
- Added visual separators for better output readability
- Included timestamp for each reading for better tracking

Future Enhancements I Could Add:
- Save readings to a CSV file
- Plot temperature graph using matplotlib
- Add multiple sensor support
- Implement alarm thresholds
- Add data export functionality

This practical gave me hands-on experience with Python basics and helped me understand how to structure a simple data collection and analysis program.
